import geemap               # Ferramentas para integra√ß√£o com o Google Earth Engine e mapas interativos
import ee                   # Biblioteca oficial do Google Earth Engine para Python (processamento de dados geoespaciais)
import geemap.foliumap as geemap  # Vers√£o do geemap baseada no folium, usada para renderizar mapas no Streamlit

from datetime import datetime       # Utilizado para manipular datas (sele√ß√£o do per√≠odo de an√°lise)
import streamlit as st              # Framework principal do app (interface web interativa)
from streamlit_folium import st_folium  # Permite integrar mapas Folium interativos ao Streamlit

import folium                # Biblioteca de mapas interativos baseada em Leaflet.js (usada para desenho da ROI)
import plotly.express as px  # Gr√°ficos simples e r√°pidos)
import plotly.graph_objects as go  # Usado para gr√°ficos avan√ßados (ex: s√©rie temporal, indicadores)

import altair as alt         # Biblioteca de visualiza√ß√£o declarativa (usada para o gr√°fico de calor e s√©ries temporais do PDSI)
import pandas as pd          # Manipula√ß√£o de tabelas e dataframes
import time                  # Pausa no processamento (ex: spinner de carregamento)
import geopandas as gpd      # ‚ö†Ô∏è N√£o est√° sendo utilizada diretamente (mas pode estar usada dentro de `convert_to_geodf`)
from utils_geo import convert_to_geodf  # Fun√ß√£o personalizada que converte o upload em GeoDataFrame
import json                  # Manipula√ß√£o de GeoJSONs e estrutura√ß√£o dos dados para download/sess√£o
import tempfile
from google.oauth2 import service_account
from ee import oauth
 

# ====================================================
# CONFIGURA√á√ÉO INICIAL DA P√ÅGINA
# ====================================================
st.set_page_config(layout="wide")
# Inicializa um mapa apenas para garantir autentica√ß√£o do Earth Engine
auth_map = geemap.Map()
st.title('An√°lise Vari√°veis Clim√°ticas (P - ET)')
st.markdown("""
O APP permite que o usu√°rio visualize uma s√©rie temporal mensal de Precipita√ß√£o, 
Evapotranspira√ß√£o, Balan√ßo H√≠drico (P-ET) e √çndice de Seca Palmer.   
Para constru√ß√£o deste APP foram utilizadas imagens CHIRPS, MOD16 e TERRACLIMATE.
""")

# Spinner de carregamento inicial
st.subheader('Processamento de dados', divider='blue')
with st.spinner('Aguarde o processamento dos dados...'):
    time.sleep(2)
st.success('Informa√ß√µes Processadas!')

# ====================================================
# BARRA LATERAL (SIDEBAR) - Upload e desenho da ROI
# ====================================================
st.sidebar.image("asset/ambgeo.png")

# Upload de arquivo com geometria
uploaded_file = st.sidebar.file_uploader(
    "Fa√ßa o upload da sua √°rea de estudo", 
    type=["geojson", "kml", "kmz", "gpkg", "zip"]
)

# Alternativa: desenho direto da ROI
st.sidebar.markdown("### Ou desenhe sua √°rea no mapa abaixo ‚¨áÔ∏è")

# ====================================================
# DEFINI√á√ÉO DA REGI√ÉO DE INTERESSE (ROI)
# ====================================================
roi = None  # Vari√°vel global para armazenar a ROI

# CASO 1: Nenhum upload e nenhuma ROI na sess√£o ‚Üí mapa para desenho
if uploaded_file is None and "roi_uploaded" not in st.session_state:
    st.subheader("Desenhe sua √°rea de interesse")
  

    # Cria mapa base com ferramenta de desenho
    folium_map = folium.Map(location=[-14, -54], zoom_start=5)
    draw = folium.plugins.Draw(export=True)
    draw.add_to(folium_map)

    # Captura do desenho feito pelo usu√°rio
    draw_result = st_folium(folium_map, height=600, width=1000)

    # Se houver geometria desenhada, define como ROI
    if draw_result and draw_result.get("all_drawings"):
        feature = draw_result["all_drawings"][0]
        geojson_geom = feature["geometry"]
        roi = ee.Geometry(geojson_geom)

        # Salva no estado da sess√£o para reutiliza√ß√£o futura
        st.session_state["roi_uploaded"] = True
        st.session_state["roi_geojson"] = feature

        # Feedback e bot√£o de download da ROI
        st.sidebar.success("‚úÖ ROI desenhada definida.")
        st.sidebar.download_button(
            "üì• Baixar ROI", 
            data=json.dumps(feature), 
            file_name="roi.geojson", 
            mime="application/geo+json"
        )
        st.rerun()

# CASO 2: Upload de arquivo vetorial ‚Üí define a ROI
elif uploaded_file is not None:
    try:
        # Converte arquivo carregado em GeoDataFrame e depois para FeatureCollection do EE
        gdf = convert_to_geodf(uploaded_file)
        shp_json = gdf.to_json()
        f_json = json.loads(shp_json)['features']
        roi = ee.FeatureCollection(f_json)

        # Salva a geometria no estado da sess√£o
        st.session_state["roi_uploaded"] = True
        st.session_state["roi_geojson"] = {
            "type": "Feature",
            "geometry": f_json[0]['geometry']
        }

        st.sidebar.success("‚úÖ Arquivo carregado com sucesso!")
    except Exception as e:
        st.sidebar.error(f"Erro ao carregar o arquivo: {e}")

# CASO 3: ROI j√° definida anteriormente ‚Üí carrega da sess√£o
elif "roi_uploaded" in st.session_state:
    geojson_geom = st.session_state["roi_geojson"]["geometry"]
    roi = ee.Geometry(geojson_geom)

# ====================================================
# VISUALIZA√á√ÉO DA ROI NO MAPA (GEEMAP)
# ====================================================
if roi is not None and not st.session_state.get("analysis_done", False):
    st.subheader("Visualiza√ß√£o da Regi√£o de Interesse")

    # Cria o mapa GEEMAP com a ROI
    m = geemap.Map(height=600)
    m.centerObject(roi, 8)
    m.setOptions("HYBRID")
    m.addLayer(roi, {}, "Regi√£o de Interesse")

    # O mapa ainda n√£o est√° sendo renderizado neste trecho
    # Para exibir: descomente a linha abaixo
    # m.to_streamlit()

    
######################## COLE√á√ÉO DE IMAGENS ########################

# Sidebar - sele√ß√£o de datas e bot√£o de an√°lise
start_date = st.sidebar.date_input("Selecione a data inicial", datetime(2024, 1, 1))
end_date = st.sidebar.date_input("Selecione a data final", datetime.now())
run_analysis = st.sidebar.button("üöÄ Executar An√°lise")

# Executa o processamento somente se ROI foi definida e bot√£o clicado
if roi is not None and run_analysis:

    ## Abrindo nossos dados
    chirps = ee.ImageCollection("UCSB-CHG/CHIRPS/PENTAD").select('precipitation')

    # Definindo a fun√ß√£o de escala
    def scale_mod16(image):
        return image.multiply(0.1).copyProperties(image, image.propertyNames())

    mod16 = ee.ImageCollection("MODIS/061/MOD16A2GF").map(scale_mod16 ).select('ET')

    ## Defini√ß√£o de per√≠odo
    year_start = start_date.year
    year_end = end_date.year

    # Par√¢metros para padroniza√ß√£o temporal
    startDate = ee.Date.fromYMD(year_start, 1, 1)
    endDate = ee.Date.fromYMD(year_end, 1, 1)  # Avan√ßa o ano inicial mais x

    # Filtrar a cole√ß√£o a partir do per√≠odo definido
    yearFiltered = chirps.filter(ee.Filter.date(startDate, endDate)).filterBounds(roi)
    # print('Numero de imagens',yearFiltered.size().getInfo())

    # Lista de meses e anos
    months = ee.List.sequence(1, 12)
    years = ee.List.sequence(year_start, (year_end - 1))

    # Fun√ß√£o para criar imagens mensais
    def createYearly(year):

        def createMonthlyImage(month):
            return yearFiltered \
                .filter(ee.Filter.calendarRange(year, year, 'year')) \
                .filter(ee.Filter.calendarRange(month, month, 'month')) \
                .sum() \
                .clip(roi) \
                .set('year', year) \
                .set('month', month) \
                .set('data', ee.Date.fromYMD(year, month, 1).format()) \
                .set('system:time_start', ee.Date.fromYMD(year, month, 1))

        return months.map(createMonthlyImage)

    # Aplicar fun√ß√£o m√™s/ano nas cole√ß√µes
    chirps_monthlyImages = ee.ImageCollection.fromImages(years.map(createYearly).flatten())
    yearFiltered = mod16.filter(ee.Filter.date(startDate, endDate)).filterBounds(roi)
    mod16_monthlyImages = ee.ImageCollection.fromImages(years.map(createYearly).flatten())

    # Verificar n√∫mero de bandas
    def addNumBands(image):
        num_bands = image.bandNames().size()
        return image.set('nbands', num_bands)

    # Aplica a fun√ß√£o e filtra imagens com bandas v√°lidas
    mod16_monthlyImages = mod16_monthlyImages.map(addNumBands).filter(ee.Filter.gt('nbands', 0))
    chirps_monthlyImages = chirps_monthlyImages.map(addNumBands).filter(ee.Filter.gt('nbands', 0))

    ## C√°lculo do Balan√ßo H√≠drico
    def calculateWaterBalance(image):
        P = image.select('precipitation')
        ET = image.select('ET')
        waterBalance = P.subtract(ET)
        return image.addBands([waterBalance.rename('water_balance')])

    # Adicionar bandas de precipita√ß√£o e evapotranspira√ß√£o √†s imagens CHIRPS
    def addETBands(image):
        ET_image = mod16_monthlyImages \
            .filter(ee.Filter.eq('year', image.get('year'))) \
            .filter(ee.Filter.eq('month', image.get('month'))) \
            .first()
        return image.addBands([ET_image.rename('ET')])

    # Aplica as fun√ß√µes
    waterBalanceWithBands = chirps_monthlyImages.map(addETBands)
    waterBalanceResult = waterBalanceWithBands.map(calculateWaterBalance)

    ## Fun√ß√£o para extrair estat√≠sticas das imagens
    def stats(image):
        reduce = image.reduceRegions(**{
            'collection': roi,
            'reducer': ee.Reducer.mean(),
            'scale': 5000
        })

        reduce = reduce \
            .map(lambda f: f.set({'data': image.get('data')})) \
            .map(lambda f: f.set({'year': image.get('year')})) \
            .map(lambda f: f.set({'month': image.get('month')}))

        return reduce.copyProperties(image, image.propertyNames())

    # Converter para df
    col_bands = waterBalanceResult  # .select(bands)

    # Aplicar estat√≠sticas
    stats_reduce = col_bands.map(stats) \
        .flatten() \
        .sort('data', True)
   

    df = geemap.ee_to_df(stats_reduce)
    

    ## Criando o gr√°fico com Plotly
    fig = go.Figure()

    # Barras para balan√ßo h√≠drico (eixo secund√°rio)
    fig.add_trace(go.Bar(
        x=df['data'], 
        y=df['water_balance'], 
        name='Wb', 
        yaxis='y2', 
        marker_color='orange'
    ))

    # Linhas para ET e Precipita√ß√£o
    fig.add_trace(go.Scatter(
        x=df['data'], 
        y=df['ET'], 
        mode='lines', 
        name='ET', 
        line=dict(color='green')
    ))
    fig.add_trace(go.Scatter(
        x=df['data'], 
        y=df['precipitation'], 
        mode='lines', 
        name='P', 
        line=dict(color='blue')
    ))

    # Layout do gr√°fico
    fig.update_layout(
        title='Balan√ßo H√≠drico (P-ET)',
        yaxis=dict(title='ET & P mm/m'),
        yaxis2=dict(title='Wb (mm/m)', overlaying='y', side='right')
    )


    ######################## PDSI - Palmer Drought Severity Index ###############################

    # Fun√ß√£o para aplicar escala e definir data nas imagens PDSI
    def scale_pdsi(image):
        return image.multiply(0.01).clip(roi) \
                    .set('data', image.date().format('YYYY-MM-dd')) \
                    .copyProperties(image, image.propertyNames())

    # Cole√ß√£o PDSI (TERRACLIMATE)
    pdsi = ee.ImageCollection("IDAHO_EPSCOR/TERRACLIMATE") \
                .select('pdsi') \
                .map(scale_pdsi) \
                .filter(ee.Filter.date(startDate, endDate)) \
                .filterBounds(roi)

    # Redu√ß√£o espacial - c√°lculo de m√©dia por ROI
    def stats_pdsi(image):
        reduce = image.reduceRegions(**{
            'collection': roi,
            'reducer': ee.Reducer.mean(),
            'scale': 5000
        })

        reduce = reduce.map(lambda f: f.set({'data': image.get('data')}))
        return reduce.copyProperties(image, image.propertyNames())

    # Reduz, ordena e renomeia colunas
    stats_reduce = pdsi.map(stats_pdsi) \
                    .flatten() \
                    .sort('data', True) \
                    .select(['data', 'mean'], ['data', 'pdsi'])

    # Converte os dados para DataFrame
    df_pdsi = geemap.ee_to_df(stats_reduce)

    # Convers√£o de data para datetime
    df_pdsi['data'] = pd.to_datetime(df_pdsi['data'])

    # Extra√ß√£o de m√™s e ano
    df_pdsi['mes'] = df_pdsi['data'].dt.month
    df_pdsi['ano'] = df_pdsi['data'].dt.year

    # ========================== VISUALIZA√á√ÉO PDSI ===========================

    # Gr√°fico de calor (ano x m√™s) com intensidade do PDSI
    alt_heat = alt.Chart(df_pdsi).mark_rect().encode(
        x='ano:O',
        y='mes:O',
        color=alt.Color('mean(pdsi):Q', scale=alt.Scale(scheme='redblue', domain=(-5, 5))),
        tooltip=[
            alt.Tooltip('ano:O', title='Year'),
            alt.Tooltip('mes:O', title='Month'),
            alt.Tooltip('mean(pdsi):Q', title='PDSI')
        ]
    ).properties(
        title='Mapa de Calor do √çndice de Severidade de Seca Padr√£o (PDSI)',
        width=600,
        height=300
    )

    # Gr√°fico de barras temporais (linha do tempo PDSI)
    alt_time = alt.Chart(df_pdsi).mark_bar(size=1).encode(
        x='data:T',
        y='pdsi:Q',
        color=alt.Color('pdsi:Q', scale=alt.Scale(scheme='redblue', domain=(-5, 5))),
        tooltip=[
            alt.Tooltip('data:T', title='Date'),
            alt.Tooltip('pdsi:Q', title='PDSI')
        ]
    ).properties(
        title='S√©rie hist√≥rica √çndice de Severidade de Seca Padr√£o (PDSI)',
        width=600,
        height=300
    )

    # ======================= INDICADORES (EXCEDENTE / D√âFICIT H√çDRICO) ==========================

    # Layout padr√£o do gr√°fico de indicadores
    layout = go.Layout(
        width=800,
        height=400,
        margin=dict(t=50, b=50, l=50, r=50),
    )

    # Calcula a m√©dia da coluna 'water_balance'
    mean_water_balance = df['water_balance'].mean()

    # Remove o sufixo de hora para melhor visualiza√ß√£o textual
    df['data'] = pd.to_datetime(df['data']).dt.date

    # Verifica excedente e d√©ficit com base na m√©dia
    excess = df['water_balance'] > mean_water_balance
    deficit = df['water_balance'] < mean_water_balance

    # Obt√©m os extremos de excedente e d√©ficit e suas datas
    max_excess_value = df.loc[excess, 'water_balance'].max()
    max_excess_date = df.loc[df['water_balance'] == max_excess_value, 'data'].values[0]

    min_deficit_value = df.loc[deficit, 'water_balance'].min()
    min_deficit_date = df.loc[df['water_balance'] == min_deficit_value, 'data'].values[0]

    # Cria√ß√£o do gr√°fico com indicadores
    fig_2 = go.Figure(layout=layout)

    # Indicador: Excedente H√≠drico
    fig_2.add_trace(go.Indicator(
        mode="number+delta+gauge",
        value=max_excess_value,  # Maior valor de excedente h√≠drico
        delta={'reference': mean_water_balance},  # Compara√ß√£o com a m√©dia
        gauge={
            'axis': {'visible': True, 'range': [None, df['water_balance'].max()]},
            'steps': [{'range': [mean_water_balance, df['water_balance'].max()], 'color': "lightgray"}],
            'threshold': {
                'line': {'color': "green", 'width': 4},
                'thickness': 0.75,
                'value': mean_water_balance
            }
        },
        title={"text": f"Excedente h√≠drico (Data: {max_excess_date})"},
        domain={'x': [0, 0.5], 'y': [0, 1]}
    ))

    # Indicador: D√©ficit H√≠drico
    fig_2.add_trace(go.Indicator(
        mode="number+delta+gauge",
        value=min_deficit_value,  # Menor valor de d√©ficit
        delta={'reference': mean_water_balance},
        gauge={
            'axis': {'visible': True, 'range': [None, df['water_balance'].max()]},
            'steps': [{'range': [df['water_balance'].min(), mean_water_balance], 'color': "lightgray"}],
            'threshold': {
                'line': {'color': "red", 'width': 4},
                'thickness': 0.75,
                'value': mean_water_balance
            }
        },
        title={"text": f"D√©ficit (Data: {min_deficit_date})"},
        domain={'x': [0.5, 1], 'y': [0, 1]}
    ))


    ############## Dados principais ###################################################

    # Calcular valores m√°ximos, m√©dios e m√≠nimos para ET, Precipita√ß√£o e PDSI
    max_et = df['ET'].max()
    min_et = df['ET'].min()
    mean_et = df['ET'].mean()

    max_precipitation = df['precipitation'].max()
    min_precipitation = df['precipitation'].min()
    mean_precipitation = df['precipitation'].mean()

    max_pdsi = df_pdsi['pdsi'].max()
    min_pdsi = df_pdsi['pdsi'].min()
    mean_pdsi = df_pdsi['pdsi'].mean()

    # Layout de 3 colunas para mostrar m√©tricas principais
    col1, col2, col3 = st.columns(3)

    # Inserir os valores calculados nas colunas com formato de m√©tricas
    col1.metric("ET", f"M√≠n: {min_et:.2f}, M√©d: {mean_et:.2f}, M√°x: {max_et:.2f}", "")
    col2.metric("Precipita√ß√£o", f"M√≠n: {min_precipitation:.2f}, M√©d: {mean_precipitation:.2f}, M√°x: {max_precipitation:.2f}", "")
    col3.metric("PDSI", f"M√≠n: {min_pdsi:.2f}, M√©d: {mean_pdsi:.2f}, M√°x: {max_pdsi:.2f}", "")

    # Separador visual
    st.divider()

    # Layout de 3 colunas para visualiza√ß√£o dos gr√°ficos e da tabela
    col4, col5, col6 = st.columns([0.3, 0.3, 0.4])

    # Gr√°fico da s√©rie hist√≥rica do balan√ßo h√≠drico
    with col4:
        st.subheader('üìà Balan√ßo H√≠drico - S√©rie Hist√≥rica')
        st.plotly_chart(fig, use_container_width=True)

    # Exibi√ß√£o da tabela com dados extra√≠dos
    with col5:
        st.subheader("üóÉTabela de dados")
        st.dataframe(df, height=500)

    # Gr√°fico dos indicadores de excedente e d√©ficit
    with col6:
        st.subheader('üìà An√°lise H√≠drica (P-ET)')
        st.plotly_chart(fig_2, use_container_width=True)

    # Se√ß√£o PDSI
    st.subheader('√çndice de Seca PDSI', divider='blue')

    # Layout com dois gr√°ficos: linha do tempo e mapa de calor
    col7, col8 = st.columns([0.5, 0.5])

    # Gr√°fico temporal do PDSI
    with col7:
        st.altair_chart(alt_time, theme="streamlit", use_container_width=True)

    # Mapa de calor PDSI por m√™s/ano
    with col8:
        st.altair_chart(alt_heat, theme="streamlit", use_container_width=True)

    # Se√ß√£o final: visualiza√ß√£o espacial das m√©dias
    st.subheader('Visualiza√ß√£o das imagens', divider='blue')

    # Centraliza o mapa na ROI com zoom ajustado
    m.centerObject(roi, 13)

    # Adiciona camadas ao mapa: ROI, PDSI m√©dio, ET m√©dio e Precipita√ß√£o m√©dia
    m.addLayer(roi, {}, 'Regi√£o de Interesse')
    m.addLayer(pdsi.mean(), {
        'palette': ['red', 'orange', 'cyan', 'blue'],
        'min': -1,
        'max': 2
    }, 'PDSI')

    m.addLayer(waterBalanceResult.select('ET').mean(), {
        'palette': ['red', 'orange', 'cyan', 'blue'],
        'min': 0,
        'max': 100
    }, 'ET')

    m.addLayer(waterBalanceResult.select('precipitation').mean(), {
        'palette': ['red', 'orange', 'cyan', 'blue'],
        'min': 0,
        'max': 100
    }, 'Precipitation')

    # Expander na barra lateral com resumo das imagens utilizadas
    expander = st.sidebar.expander('Clique para saber mais')
    size_collection = waterBalanceResult.size().getInfo()
    expander.write(
        f"""
        Para a an√°lise de dados de est√£o sendo utilizadas {size_collection} imagens.
        """
    )

# # Exibe o mapa no Streamlit
# Exibe o mapa no Streamlit apenas se 'm' existir
if 'm' in locals():
    m.to_streamlit()
    
# if st.sidebar.button("üîÅ Nova an√°lise"):
#     st.session_state.clear()
#     st.rerun()

st.sidebar.markdown('Desenvolvido por [Christhian Cunha](https://www.linkedin.com/in/christhian-santana-cunha/)') 